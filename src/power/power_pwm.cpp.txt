/*
  https://shawnhymel.com/1710/arduino-zero-samd21-raw-pwm-using-cmsis/  ??
  Output PWM 24Khz on digital pin PA16 (D11 SAMD21 MINI)
  SAMD21 pin 11
  using timer TCC2 (10-bit resolution), channel CH0
  Версия от 23 октября 2020г.

VER190:
  https://shawnhymel.com/1710/arduino-zero-samd21-raw-pwm-using-cmsis/

*/

#include "power/power_pwm.h"
#include <Arduino.h>

#ifdef VER190
// Number to count to with PWM (TOP value). Frequency can be calculated by
// freq = GCLK4_freq / (TCC0_prescaler * (1 + TOP_value))
// With TOP of 47, we get a 1 MHz square wave in this example

//uint32_t period = 48 - 1;
constexpr uint32_t pwm_period = 48 - 1;       // 

uint32_t           pwmPeriod  = pwm_period;   // 1/Freq
constexpr bool     pwm_invert = false;        //
bool pwmInvert                = pwm_invert;   // 0 - активный уровень


void initPwm() {

  // Because we are using TCC0, limit period to 24 bits
  pwmPeriod = ( pwmPeriod < 0x00ffffff ) ? pwmPeriod : 0x00ffffff;

  // Enable and configure generic clock generator 4
  GCLK->GENCTRL.reg = GCLK_GENCTRL_IDC |          // Improve duty cycle
                      GCLK_GENCTRL_GENEN |        // Enable generic clock gen
                      GCLK_GENCTRL_SRC_DFLL48M |  // Select 48MHz as source
                      GCLK_GENCTRL_ID(4);         // Select GCLK4
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  // Set clock divider of 1 to generic clock generator 4
  GCLK->GENDIV.reg = GCLK_GENDIV_DIV(5) |         // Divide 48 MHz by 8
                     GCLK_GENDIV_ID(4);           // Apply to GCLK4 4
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization
  
  // Enable GCLK4 and connect it to TCC0 and TCC1
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |        // Enable generic clock
                      GCLK_CLKCTRL_GEN_GCLK4 |    // Select GCLK4
                      GCLK_CLKCTRL_ID_TCC0_TCC1;  // Feed GCLK4 to TCC0/1
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  // Divide counter by 1 giving 48 MHz (20.83 ns) on each TCC0 tick
  TCC0->CTRLA.reg |= TCC_CTRLA_PRESCALER(TCC_CTRLA_PRESCALER_DIV1_Val);

  // Use "Normal PWM" (single-slope PWM): count up to PER, match on CC[n]
  TCC0->WAVE.reg = TCC_WAVE_WAVEGEN_NPWM;         // Select NPWM as waveform
  while (TCC0->SYNCBUSY.bit.WAVE);                // Wait for synchronization

  // Set the pwmPeriod (the number to count to (TOP) before resetting timer)
  TCC0->PER.reg = pwmPeriod;
  while (TCC0->SYNCBUSY.bit.PER);

  // Set PWM signal to output 50% duty cycle
  // n for CC[n] is determined by n = x % 4 where x is from WO[x]
  TCC0->CC[2].reg = pwmPeriod / 2;
  while (TCC0->SYNCBUSY.bit.CC2);

  // Configure PA18 (D10 on Arduino Zero) to be output
  // PORT->Group[PORTA].DIRSET.reg = PORT_PA18;      // Set pin as output
  // PORT->Group[PORTA].OUTCLR.reg = PORT_PA18;      // Set pin to low
  PORT->Group[PORTA].DIRSET.reg = PORT_PA16;      // Set pin as output
  PORT->Group[PORTA].OUTCLR.reg = PORT_PA16;      // Set pin to low

  // Enable the port multiplexer for PA18
  //PORT->Group[PORTA].PINCFG[18].reg |= PORT_PINCFG_PMUXEN;
  PORT->Group[PORTA].PINCFG[16].reg |= PORT_PINCFG_PMUXEN;

  // Connect TCC0 timer to PA18. Function F is TCC0/WO[2] for PA18.
  // Odd pin num (2*n + 1): use PMUXO
  // Even pin num (2*n): use PMUXE
  //PORT->Group[PORTA].PMUX[9].reg = PORT_PMUX_PMUXE_F;
  PORT->Group[PORTA].PMUX[8].reg = PORT_PMUX_PMUXE_F;

  // Enable output (start PWM)
  TCC0->CTRLA.reg |= (TCC_CTRLA_ENABLE);
  while (TCC0->SYNCBUSY.bit.ENABLE);              // Wait for synchronization
}

void writePwm(uint16_t value)
{
  REG_TCC2_CC0 = value;                           // TCC2 CC0 - on D11 - PWM signalling
  while (TCC2->SYNCBUSY.bit.CC3);                 // Wait for synchronization
}

#else
  // Переменные настройки PWM (пока нет eeprom)
constexpr uint16_t pwm_period = 0x1000;       // Freq = 5.865 kHz (без вариантов 12бит)
//constexpr uint16_t pwm_period = 0x1000;       // Freq =  .  kHz (8 бит)
uint16_t            pwmPeriod = pwm_period;   // 1/Freq
constexpr bool     pwm_invert = false;        //
bool pwmInvert                = pwm_invert;   // 0 - активный уровень

void initPwm()
{
  REG_GCLK_GENDIV = GCLK_GENDIV_DIV(1) |      // Divide the 48MHz clock source by divisor N=1: 48MHz/1=48MHz
                    GCLK_GENDIV_ID(4);        // Select Generic Clock (GCLK) 4
  while (GCLK->STATUS.bit.SYNCBUSY);          // Wait for synchronization

  REG_GCLK_GENCTRL = GCLK_GENCTRL_IDC |           // Set the duty cycle to 50/50 HIGH/LOW
                     GCLK_GENCTRL_GENEN |         // Enable GCLK4
                     GCLK_GENCTRL_SRC_DFLL48M |   // Set the 48MHz clock source
                     GCLK_GENCTRL_ID(4);          // Select GCLK4
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  // Enable the port multiplexer for the digital 
  // pin D11 g_APinDescription() converts Arduino Pin to SAMD21 pin
  PORT->Group[g_APinDescription[11].ulPort].PINCFG[g_APinDescription[11].ulPin].bit.PMUXEN = 1;
  
  // Connect the TCC2 timer to digital output D11 - port pin
  PORT->Group[g_APinDescription[11].ulPort].PMUX[g_APinDescription[11].ulPin >> 1].reg = PORT_PMUX_PMUXE_E ;   // use device E on TCC2/WO[0]

  // Feed GCLK4 to TCC2
  REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN |         // Enable GCLK4
                     GCLK_CLKCTRL_GEN_GCLK4 |     // Select GCLK4
                     GCLK_CLKCTRL_ID_TCC2_TC3;    // Feed GCLK4 to TCC2
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  // Dual slope PWM operation: timers countinuously count up to PER register value then down 0
  if( pwmInvert )
  {
    REG_TCC2_WAVE |= TCC_WAVE_WAVEGEN_DSBOTH;
    while (TCC2->SYNCBUSY.bit.WAVE);              // Wait for synchronization
  }
  else
  {
    REG_TCC2_WAVE |= TCC_WAVE_POL(0X0F) | TCC_WAVE_WAVEGEN_DSBOTH;
    while (TCC2->SYNCBUSY.bit.WAVE);              // Wait for synchronization
  }

  // Timer counts up to a maximum or TOP value set by the PER register,
  // this determines the frequency of the PWM operation:
  // Freq = 48Mhz/(2*N*PER)
  REG_TCC2_PER = pwmPeriod;                       // Set the FreqTcc of the PWM on TCC1 to specified Khz
  while (TCC2->SYNCBUSY.bit.PER);                 // Wait for synchronization
 
  // Set the PWM signal to output,
  // PWM ds = 2*N(TOP-CCx)/Freqtcc => PWM=0 => CCx=PER,
  // PWM=50% => CCx = PER/2
  REG_TCC2_CC0 = 0;                               // TCC2 CC0 - on D11
  while (TCC2->SYNCBUSY.bit.CC0);                 // Wait for synchronization
 
  // Divide the GCLOCK signal by 1 giving 
  // in this case 48MHz (20.83ns) TCC2 timer tick and enable the outputs
  REG_TCC2_CTRLA |= TCC_CTRLA_PRESCALER_DIV1 |    // Divide GCLK4 by 1
                    TCC_CTRLA_ENABLE;             // Enable the TCC2 output
  while (TCC2->SYNCBUSY.bit.ENABLE);              // Wait for synchronization
}

void writePwm(uint16_t value)
{
  REG_TCC2_CC0 = value;                           // TCC2 CC0 - on D11 - PWM signalling
  while (TCC2->SYNCBUSY.bit.CC3);                 // Wait for synchronization
}

#endif